<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Detached Context | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="func (s *service) DoSomethingWithContext(
	ctx context.Context,
	idA string,
	idB string,
) (*model.SomeStatus, error) {
	req := someapi.TriggerRequest{
		FieldA: idA,
		FieldB: idB,
	}
	noCancelCTX := nocancel.FromContext(ctx)

	go func() {
		// Defer cancelFunc to ensure the context lives through the RPC
		newCtx, cancel := context.WithTimeout(noCancelCTX, 10*time.Minute)
		defer cancel()

		resp, err := s.client.TriggerAction(
			newCtx,
			connect.NewRequest(&amp;req),
		)
		if err != nil {
			telemetry.L(ctx).Error(&#34;Async action failed&#34;, zap.Error(err))
		} else {
			telemetry.L(ctx).Info(&#34;Async action succeeded&#34;, zap.Any(&#34;status&#34;, model.SomeStatus(resp.Msg.Status)))
		}
	}()

	return ptr.To(model.SomeStatusStarted), nil
}
1.Â noCancelCTX := nocancel.FromContext(ctx)
It takes an existingÂ context.ContextÂ (ctx) andÂ returns a new context that is not canceled when the original one is. This is useful when you want toÂ detach a background taskÂ from the lifecycle of the incoming request.
âœ… Why use it?
IfÂ ctxÂ is tied to an HTTP request or RPC call, it will be canceled when the client disconnects or the request times out.By usingÂ nocancel.FromContext(ctx), you&rsquo;re saying:">
    <meta name="generator" content="Hugo 0.145.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/detached-context/">
    

    <meta property="og:url" content="http://localhost:1313/posts/detached-context/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Detached Context">
  <meta property="og:description" content="func (s *service) DoSomethingWithContext( ctx context.Context, idA string, idB string, ) (*model.SomeStatus, error) { req := someapi.TriggerRequest{ FieldA: idA, FieldB: idB, } noCancelCTX := nocancel.FromContext(ctx) go func() { // Defer cancelFunc to ensure the context lives through the RPC newCtx, cancel := context.WithTimeout(noCancelCTX, 10*time.Minute) defer cancel() resp, err := s.client.TriggerAction( newCtx, connect.NewRequest(&amp;req), ) if err != nil { telemetry.L(ctx).Error(&#34;Async action failed&#34;, zap.Error(err)) } else { telemetry.L(ctx).Info(&#34;Async action succeeded&#34;, zap.Any(&#34;status&#34;, model.SomeStatus(resp.Msg.Status))) } }() return ptr.To(model.SomeStatusStarted), nil } 1.Â noCancelCTX := nocancel.FromContext(ctx) It takes an existingÂ context.ContextÂ (ctx) andÂ returns a new context that is not canceled when the original one is. This is useful when you want toÂ detach a background taskÂ from the lifecycle of the incoming request. âœ… Why use it? IfÂ ctxÂ is tied to an HTTP request or RPC call, it will be canceled when the client disconnects or the request times out.By usingÂ nocancel.FromContext(ctx), youâ€™re saying:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-05T14:54:42+02:00">
    <meta property="article:modified_time" content="2025-05-05T14:54:42+02:00">

  <meta itemprop="name" content="Detached Context">
  <meta itemprop="description" content="func (s *service) DoSomethingWithContext( ctx context.Context, idA string, idB string, ) (*model.SomeStatus, error) { req := someapi.TriggerRequest{ FieldA: idA, FieldB: idB, } noCancelCTX := nocancel.FromContext(ctx) go func() { // Defer cancelFunc to ensure the context lives through the RPC newCtx, cancel := context.WithTimeout(noCancelCTX, 10*time.Minute) defer cancel() resp, err := s.client.TriggerAction( newCtx, connect.NewRequest(&amp;req), ) if err != nil { telemetry.L(ctx).Error(&#34;Async action failed&#34;, zap.Error(err)) } else { telemetry.L(ctx).Info(&#34;Async action succeeded&#34;, zap.Any(&#34;status&#34;, model.SomeStatus(resp.Msg.Status))) } }() return ptr.To(model.SomeStatusStarted), nil } 1.Â noCancelCTX := nocancel.FromContext(ctx) It takes an existingÂ context.ContextÂ (ctx) andÂ returns a new context that is not canceled when the original one is. This is useful when you want toÂ detach a background taskÂ from the lifecycle of the incoming request. âœ… Why use it? IfÂ ctxÂ is tied to an HTTP request or RPC call, it will be canceled when the client disconnects or the request times out.By usingÂ nocancel.FromContext(ctx), youâ€™re saying:">
  <meta itemprop="datePublished" content="2025-05-05T14:54:42+02:00">
  <meta itemprop="dateModified" content="2025-05-05T14:54:42+02:00">
  <meta itemprop="wordCount" content="335">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Detached Context">
  <meta name="twitter:description" content="func (s *service) DoSomethingWithContext( ctx context.Context, idA string, idB string, ) (*model.SomeStatus, error) { req := someapi.TriggerRequest{ FieldA: idA, FieldB: idB, } noCancelCTX := nocancel.FromContext(ctx) go func() { // Defer cancelFunc to ensure the context lives through the RPC newCtx, cancel := context.WithTimeout(noCancelCTX, 10*time.Minute) defer cancel() resp, err := s.client.TriggerAction( newCtx, connect.NewRequest(&amp;req), ) if err != nil { telemetry.L(ctx).Error(&#34;Async action failed&#34;, zap.Error(err)) } else { telemetry.L(ctx).Info(&#34;Async action succeeded&#34;, zap.Any(&#34;status&#34;, model.SomeStatus(resp.Msg.Status))) } }() return ptr.To(model.SomeStatusStarted), nil } 1.Â noCancelCTX := nocancel.FromContext(ctx) It takes an existingÂ context.ContextÂ (ctx) andÂ returns a new context that is not canceled when the original one is. This is useful when you want toÂ detach a background taskÂ from the lifecycle of the incoming request. âœ… Why use it? IfÂ ctxÂ is tied to an HTTP request or RPC call, it will be canceled when the client disconnects or the request times out.By usingÂ nocancel.FromContext(ctx), youâ€™re saying:">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Detached Context</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-05-05T14:54:42+02:00">May 5, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">service</span>) <span style="color:#a6e22e">DoSomethingWithContext</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">idA</span> <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">idB</span> <span style="color:#66d9ef">string</span>,
</span></span><span style="display:flex;"><span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">model</span>.<span style="color:#a6e22e">SomeStatus</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">req</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">someapi</span>.<span style="color:#a6e22e">TriggerRequest</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">FieldA</span>: <span style="color:#a6e22e">idA</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">FieldB</span>: <span style="color:#a6e22e">idB</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">noCancelCTX</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nocancel</span>.<span style="color:#a6e22e">FromContext</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Defer cancelFunc to ensure the context lives through the RPC</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newCtx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">noCancelCTX</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">resp</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">TriggerAction</span>(
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">newCtx</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">connect</span>.<span style="color:#a6e22e">NewRequest</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">req</span>),
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">telemetry</span>.<span style="color:#a6e22e">L</span>(<span style="color:#a6e22e">ctx</span>).<span style="color:#a6e22e">Error</span>(<span style="color:#e6db74">&#34;Async action failed&#34;</span>, <span style="color:#a6e22e">zap</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">err</span>))
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">telemetry</span>.<span style="color:#a6e22e">L</span>(<span style="color:#a6e22e">ctx</span>).<span style="color:#a6e22e">Info</span>(<span style="color:#e6db74">&#34;Async action succeeded&#34;</span>, <span style="color:#a6e22e">zap</span>.<span style="color:#a6e22e">Any</span>(<span style="color:#e6db74">&#34;status&#34;</span>, <span style="color:#a6e22e">model</span>.<span style="color:#a6e22e">SomeStatus</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Msg</span>.<span style="color:#a6e22e">Status</span>)))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ptr</span>.<span style="color:#a6e22e">To</span>(<span style="color:#a6e22e">model</span>.<span style="color:#a6e22e">SomeStatusStarted</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>1.Â noCancelCTX := nocancel.FromContext(ctx)
It takes an existingÂ context.ContextÂ (ctx) andÂ returns a new context that is not canceled when the original one is. This is useful when you want toÂ detach a background taskÂ from the lifecycle of the incoming request.
âœ… Why use it?
IfÂ ctxÂ is tied to an HTTP request or RPC call, it will be canceled when the client disconnects or the request times out.By usingÂ nocancel.FromContext(ctx), you&rsquo;re saying:</p>
<blockquote>
<p>&ldquo;I want this background task to keep running even if the original request is canceled.&rdquo;</p></blockquote>
<p>2.Â newContext, cancelFunc := context.WithTimeout(noCancelCTX, time.Duration(10)*time.Minute)
This line creates aÂ new context with a timeoutÂ of 10 minutes.</p>
<ul>
<li>newContextÂ is a child ofÂ noCancelCTX, and it will be automatically canceled after 10 minutes.</li>
<li>cancelFuncÂ is a function you must call (usually withÂ defer cancelFunc()) to release resources early if you&rsquo;re done before the timeout.
âœ… Why use it?
Even though you&rsquo;ve detached from the original context, you still want toÂ limit how long the background task runs, to avoid runaway processes.</li>
</ul>
<blockquote>
<p>&ldquo;Create a context that isÂ not canceledÂ when the original request ends, butÂ will automatically cancel after 10 minutesÂ to avoid running forever.&rdquo;</p></blockquote>
<p>ðŸ§ª Example Use Case
Imagine a user triggers a background re-enrollment process via an API call. You want the process to continue even if the user closes the browser â€” but you also donâ€™t want it to run forever.
This pattern ensures:</p>
<ul>
<li>âœ… The task survives client disconnects.</li>
<li>âœ… The task still has a hard timeout (10 minutes).</li>
<li>âœ… You can cancel it manually if needed.</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
